/**
 * Alert Models
 * Defines alerts and notification rules for tracking events
 */

import { GlobalTrackingId, ObjectClass } from './tracked-object';

/** Alert severity levels */
export type AlertSeverity = 'info' | 'warning' | 'critical';

/** Types of alerts the system can generate */
export type AlertType =
  | 'property_entry'
  | 'property_exit'
  | 'movement'
  | 'unusual_path'
  | 'dwell_time'
  | 'restricted_zone'
  | 'lost_tracking'
  | 'reappearance'
  | 'zone_entry'
  | 'zone_exit';

/** Alert condition operators */
export type AlertOperator = 'equals' | 'not_equals' | 'contains' | 'greater_than' | 'less_than';

/** An alert generated by the system */
export interface Alert {
  /** Unique alert ID */
  id: string;
  /** Type of alert */
  type: AlertType;
  /** Severity level */
  severity: AlertSeverity;
  /** Timestamp when alert was generated */
  timestamp: number;
  /** ID of the tracked object that triggered this alert */
  trackedObjectId: GlobalTrackingId;
  /** Human-readable message */
  message: string;
  /** Additional details */
  details: AlertDetails;
  /** Whether the alert has been acknowledged */
  acknowledged: boolean;
  /** Rule ID that generated this alert (if any) */
  ruleId?: string;
}

/** Additional details for an alert */
export interface AlertDetails {
  /** Camera device ID */
  cameraId?: string;
  /** Camera display name */
  cameraName?: string;
  /** Source camera for movement alerts */
  fromCameraId?: string;
  /** Source camera name for movement alerts */
  fromCameraName?: string;
  /** Destination camera for movement alerts */
  toCameraId?: string;
  /** Destination camera name for movement alerts */
  toCameraName?: string;
  /** Zone name (for zone-related alerts) */
  zoneName?: string;
  /** Dwell time in milliseconds (for dwell alerts) */
  dwellTime?: number;
  /** Transit time in milliseconds (for movement alerts) */
  transitTime?: number;
  /** Expected path (for unusual path alerts) */
  expectedPath?: string;
  /** Actual path taken */
  actualPath?: string;
  /** Detection ID for thumbnail */
  detectionId?: string;
  /** Object class */
  objectClass?: ObjectClass;
  /** Object label (if recognized) */
  objectLabel?: string;
  /** Thumbnail image URL or data */
  thumbnailUrl?: string;
  // --- Spatial Context from RAG ---
  /** Description of the path taken (from spatial reasoning) */
  pathDescription?: string;
  /** Names of landmarks involved in the movement */
  involvedLandmarks?: string[];
  /** Whether LLM was used for description */
  usedLlm?: boolean;
}

/** A condition for alert rules */
export interface AlertCondition {
  /** Field path to evaluate (e.g., "className", "label", "totalDwellTime") */
  field: string;
  /** Comparison operator */
  operator: AlertOperator;
  /** Value to compare against */
  value: string | number | boolean;
}

/** Alert rule configuration */
export interface AlertRule {
  /** Unique rule ID */
  id: string;
  /** Rule display name */
  name: string;
  /** Whether the rule is enabled */
  enabled: boolean;
  /** Alert type this rule generates */
  type: AlertType;
  /** Conditions that must be met */
  conditions: AlertCondition[];
  /** Severity of alerts generated */
  severity: AlertSeverity;
  /** Scrypted Notifier device IDs to send alerts to */
  notifiers: string[];
  /** Minimum time between repeat alerts (cooldown) in milliseconds */
  cooldown: number;
  /** Object classes this rule applies to (empty = all) */
  objectClasses?: ObjectClass[];
  /** Specific cameras this rule applies to (empty = all) */
  cameraIds?: string[];
  /** Specific zones this rule applies to (empty = all) */
  zoneIds?: string[];
}

/** Creates default alert rules */
export function createDefaultRules(): AlertRule[] {
  return [
    {
      id: 'property-entry',
      name: 'Property Entry',
      enabled: true,
      type: 'property_entry',
      conditions: [],
      severity: 'info',
      notifiers: [],
      cooldown: 60000, // 1 minute
    },
    {
      id: 'property-exit',
      name: 'Property Exit',
      enabled: true,
      type: 'property_exit',
      conditions: [],
      severity: 'info',
      notifiers: [],
      cooldown: 60000,
    },
    {
      id: 'movement',
      name: 'Movement Between Cameras',
      enabled: true,
      type: 'movement',
      conditions: [],
      severity: 'info',
      notifiers: [],
      cooldown: 10000, // 10 seconds - we want frequent movement updates
    },
    {
      id: 'unusual-path',
      name: 'Unusual Path Detected',
      enabled: true,
      type: 'unusual_path',
      conditions: [],
      severity: 'warning',
      notifiers: [],
      cooldown: 600000, // 10 minutes
    },
    {
      id: 'dwell-time',
      name: 'Extended Dwell Time',
      enabled: true,
      type: 'dwell_time',
      conditions: [
        { field: 'totalDwellTime', operator: 'greater_than', value: 300000 } // 5 minutes
      ],
      severity: 'warning',
      notifiers: [],
      cooldown: 600000,
    },
    {
      id: 'restricted-zone',
      name: 'Restricted Zone Entry',
      enabled: true,
      type: 'restricted_zone',
      conditions: [],
      severity: 'critical',
      notifiers: [],
      cooldown: 0, // Always alert immediately
    },
    {
      id: 'lost-tracking',
      name: 'Lost Object Tracking',
      enabled: false, // Disabled by default (can be noisy)
      type: 'lost_tracking',
      conditions: [],
      severity: 'info',
      notifiers: [],
      cooldown: 300000,
    },
  ];
}

/** Generates a human-readable message for an alert */
export function generateAlertMessage(
  type: AlertType,
  details: AlertDetails
): string {
  // Capitalize the object class for display (person -> Person, car -> Car, dog -> Dog)
  const capitalize = (s: string) => s ? s.charAt(0).toUpperCase() + s.slice(1) : 'Object';
  const objectDesc = details.objectLabel
    ? `${capitalize(details.objectClass || '')} (${details.objectLabel})`
    : capitalize(details.objectClass || '');

  switch (type) {
    case 'property_entry':
      // Use the rich description from spatial reasoning if available
      if (details.objectLabel && details.objectLabel !== details.objectClass) {
        return details.objectLabel;
      }
      // Fallback to basic description
      if (details.involvedLandmarks && details.involvedLandmarks.length > 0) {
        return `${objectDesc} entered property near ${details.involvedLandmarks[0]}`;
      }
      return `${objectDesc} entered property at ${details.cameraName || 'entrance'}`;
    case 'property_exit':
      // Use the rich description from spatial reasoning if available
      if (details.objectLabel && details.objectLabel !== details.objectClass) {
        return details.objectLabel;
      }
      // Fallback to basic description
      if (details.involvedLandmarks && details.involvedLandmarks.length > 0) {
        return `${objectDesc} left property via ${details.involvedLandmarks[0]}`;
      }
      return `${objectDesc} left property`;
    case 'movement':
      // If objectLabel contains a full description, use it directly
      if (details.objectLabel && details.objectLabel !== details.objectClass) {
        // Check if this is a cross-camera movement or initial detection
        if (details.fromCameraId && details.fromCameraId !== details.toCameraId && details.transitTime) {
          const transitSecs = Math.round(details.transitTime / 1000);
          const transitStr = transitSecs > 0 ? ` (${transitSecs}s)` : '';
          const pathContext = details.pathDescription ? ` via ${details.pathDescription}` : '';
          return `${details.objectLabel}${pathContext}${transitStr}`;
        }
        // Initial detection - use the label directly
        return details.objectLabel;
      }
      // Cross-camera movement with basic info
      if (details.fromCameraId && details.fromCameraId !== details.toCameraId) {
        const transitSecs = details.transitTime ? Math.round(details.transitTime / 1000) : 0;
        const transitStr = transitSecs > 0 ? ` (${transitSecs}s transit)` : '';
        let movementDesc = `${objectDesc} moving from ${details.fromCameraName || 'unknown'} towards ${details.toCameraName || 'unknown'}`;
        if (details.involvedLandmarks && details.involvedLandmarks.length > 0) {
          movementDesc += ` near ${details.involvedLandmarks.join(', ')}`;
        }
        return `${movementDesc}${transitStr}`;
      }
      // Initial detection without full label
      if (details.involvedLandmarks && details.involvedLandmarks.length > 0) {
        return `${objectDesc} detected near ${details.involvedLandmarks[0]}`;
      }
      return `${objectDesc} detected at ${details.cameraName || 'camera'}`;
    case 'unusual_path':
      return `${objectDesc} took unusual path: ${details.actualPath || 'unknown'}`;
    case 'dwell_time':
      const dwellMinutes = Math.round((details.dwellTime || 0) / 60000);
      return `${objectDesc} has been present for ${dwellMinutes} minutes in ${details.zoneName || details.cameraName || 'area'}`;
    case 'restricted_zone':
      return `${objectDesc} entered restricted zone: ${details.zoneName}`;
    case 'lost_tracking':
      return `Lost tracking of ${objectDesc} near ${details.cameraName || 'unknown location'}`;
    case 'reappearance':
      return `${objectDesc} reappeared on ${details.cameraName}`;
    case 'zone_entry':
      return `${objectDesc} entered ${details.zoneName}`;
    case 'zone_exit':
      return `${objectDesc} exited ${details.zoneName}`;
    default:
      return `Tracking event: ${type}`;
  }
}

/** Creates an alert instance */
export function createAlert(
  type: AlertType,
  trackedObjectId: GlobalTrackingId,
  details: AlertDetails,
  severity: AlertSeverity = 'info',
  ruleId?: string
): Alert {
  return {
    id: `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
    type,
    severity,
    timestamp: Date.now(),
    trackedObjectId,
    message: generateAlertMessage(type, details),
    details,
    acknowledged: false,
    ruleId,
  };
}
